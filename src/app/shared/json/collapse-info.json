[
    {
      "titulo": "¿Qué es el code review?",
      "complemento": [
        {
          "texto": "Una revisión de código es el proceso mediante el cual, el resto del equipo revisa en conjunto la implementación de un desarrollador, aportando ideas sobre cómo mejorarlo, quizás refactorizarlo, descubriendo posibles bugs, errores de arquitectura, falta de cobertura de tests para determinados casos, y un sinfín de cosas más que puedan surgir.",
          "element": "div"
        }
      ]
    },
    {
      "titulo": "¿Para qué utilizar el code review?",
      "complemento": [
        {
          "texto": "Existen varios motivos por los que esta práctica es interesante, sin embargo, el motivo principal para empezar a implementar  Code Review es el de mejorar la calidad del código que desarrollamos y crear una cultura de equipo en la que todos los desarrolladores se sienten importantes. Vamos a analizar distintos motivos destacables:",
          "element": "div",
          "listaUl": [
            {
              "texto": "Compromiso y motivación: Al incluir Code Review en tu flujo de trabajo, los desarrolladores se comprometen más en realizar un código más limpio y a consolidar aspectos pendientes. Al saber que tu código va a ser revisado, se tiene más precaución, se mima más el código, se incrementa el compromiso con el proyecto y aumenta la motivación del desarrollador al ser gratificado por el resto de compañeros.  Todos necesitamos que nos digan “buen trabajo” y nos sintamos parte del equipo. También es importante asumir la crítica, dejar nuestro orgullo a un lado y que esta critica sea constructiva y positiva."
            },
            {
              "texto": "Comunicación y conocimiento compartido: El mayor problema que encuentro en los equipos, especialmente en desarrollo, es la falta de comunicación. El proyecto es de todos y el código que implementamos es responsabilidad todos los miembros del equipo. Es por ello, que es importante que todo el equipo esté alineado sobre la funcionalidad que se añade o se modifica. Esta comunicación es positiva e integradora y une puentes entre el equipo. ¿No os ha pasado que dos desarrolladores han estado trabajando en la misma tarea?"
            },
            {
              "texto": "Aprendizaje: el Code Review ayuda a aumentar el nivel de calidad en toda la organización. Esto es debido a que los desarrolladores con menos experiencia pueden aprender rápidamente de aquellos con más experiencia en la tecnología que se esté utilizando. Probablemente un desarrollador con más experiencia ya haya tenido ciertos problemas por los que podrá guiarte por la mejor solución ¡Juntos somos más fuertes!"
            },
            {
              "texto": "Consistencia: Creo que es importante que el código sea consistente. Muchas veces se nota que parte del desarrollo se ha realizado por unas personas y otras, y cómo hemos comentado el código es propiedad y responsabilidad de todo el equipo, por lo que debería ser uniforme. Es importante establecer unas reglas de estilo, marcar unas estructura de carpetas y crear unas normas comunes. Esto facilita la lectura del código, prevenir errores y una mayor colaboración si un tercer desarrollador debe de ayudar en cierto proyecto pero ya conoce lo que se va a encontrar."
            }
          ]
        }
      ]
    },
    {
      "titulo": "¿Cuáles son los niveles de acceso y cómo funcionan? (Modificadores)",
      "complemento": [
        {
          "texto": "Depende de la tecnología o lenguaje de programación que se esté utilizando. Por ejemplo, en Typescript hay 3 modificadores de acceso: public, private y protected.",
          "element": "div",
          "listaUl": [
            {
              "texto": "public: Es el modificador por defecto. Esto es así porque Javascript no tiene estos modificadores y todo es público, así que por consistencia es normal que sea el valor por defecto."
            },
            {
              "texto": "private: Los elementos (atributos y métodos) sólo son visibles dentro de la clase."
            },
            {
              "texto": "protected: Los elementos sólo son visibles dentro de la clase y en las clases que hereden directamente de ésta."
            }
          ]
        }
      ]
    },
    {
      "titulo": "¿Qué patrones de arquitectura conoces y cómo funcionan? (Capas, Cliente-Servidor, Maestro-Esclavo, MVC, Etc..)",
      "complemento": [
        {
          "texto": "Un patrón arquitectónico es una solución general y reutilizable a un problema común en la arquitectura de software dentro de un contexto dado. Los patrones arquitectónicos son similares al patrón de diseño de software pero tienen un alcance más amplio.",
          "element": "div",
          "listaUl": [
            {
              "texto": "Patrón de capas: Este patrón se puede utilizar para estructurar programas que se pueden descomponer en grupos de subtareas, cada una de las cuales se encuentra en un nivel particular de abstracción. Cada capa proporciona servicios a la siguiente capa superior."
            }
          ]
        },
        {
          "texto": "Las 4 capas más comúnmente encontradas de un sistema de información general son las siguientes.",
          "element": "div",
          "listaOl": [
            {
              "texto": "Capa de presentación (también conocida como capa UI)"
            },
            {
              "texto": "Capa de aplicación (también conocida como capa de servicio)"
            },
            {
              "texto": "Capa de lógica de negocios (también conocida como capa de dominio)"
            },
            {
              "texto": "Capa de acceso a datos (también conocida como capa de persistencia)"
            }
          ]
        },
        {
          "texto": "Uso",
          "element": "div",
          "listaOl": [
            {
              "texto": "Aplicaciones de escritorio generales."
            },
            {
              "texto": "Aplicaciones web de comercio electrónico."
            }
          ]
        },
        {
          "texto": "•\tPatrón cliente-servidor: Este patrón consiste en dos partes; un servidor y múltiples clientes. El componente del servidor proporcionará servicios a múltiples componentes del cliente. Los clientes solicitan servicios del servidor y el servidor proporciona servicios relevantes a esos clientes. Además, el servidor sigue escuchando las solicitudes de los clientes. Uso:",
          "element": "div",
          "listaOl": [
            {
              "texto": "Aplicaciones en línea como correo electrónico, uso compartido de documentos y banca."
            }
          ]
        },
        {
          "texto": "•\tModelo-vista-controlador (MVC) es un patrón de arquitectura de software, que separa los datos y principalmente lo que es la lógica de negocio de una aplicación de su representación y el módulo encargado de gestionar los eventos y las comunicaciones. Para ello MVC propone la construcción de tres componentes distintos que son el modelo, la vista y el controlador, es decir, por un lado define componentes para la representación de la información, y por otro lado para la interacción del usuario.  Este patrón de arquitectura de software se basa en las ideas de reutilización de código y la separación de conceptos, características que buscan facilitar la tarea de desarrollo de aplicaciones y su posterior mantenimiento.",
          "element": "div"
        },
        {
          "texto": "•\tEl patrón de diseño Maestro / Esclavo se utiliza cuando tiene dos o más procesos que deben ejecutarse de forma simultánea y continua, pero a diferentes velocidades. Si estos procesos se ejecutan en un solo bucle, pueden producirse graves problemas de sincronización. Estos problemas de sincronización ocurren cuando una parte del ciclo tarda más en ejecutarse de lo esperado. Si esto sucede, las secciones restantes del ciclo se retrasan. El patrón maestro / esclavo consta de múltiples bucles paralelos. Cada uno de los bucles puede ejecutar tareas a diferentes velocidades. De estos bucles paralelos, uno actúa como maestro y los demás como esclavos. El bucle maestro controla todos los bucles esclavos y se comunica con ellos mediante arquitecturas de mensajería.",
          "element": "div"
        }
      ]
    },
    {
      "titulo": "¿Qué patrones de diseño conoces y cómo funcionan? (Creacionales, Estructurales, Comportamiento)",
      "complemento": [
        {
          "texto": "Patrones de creación",
          "element": "div",
          "listaUl": [
            {
              "texto": "Abstract Factory. Proporciona una interfaz para crear familias de objetos o que dependen entre sí, sin especificar sus clases concretas."
            },
            {
              "texto": "Builder. Separa la construcción de un objeto complejo de su representación, de forma que el mismo proceso de construcción pueda crear diferentes representaciones."
            },
            {
              "texto": "Factory Method. Define una interfaz para crear un objeto, pero deja que sean las subclases quienes decidan qué clase instanciar. Permite que una clase delegue en sus subclases la creación de objetos"
            },
            {
              "texto": "Prototype. Especifica los tipos de objetos a crear por medio de una instancia prototípica, y crear nuevos objetos copiando este prototipo. Singleton. Garantiza que una clase sólo tenga una instancia, y proporciona un punto de acceso global a ella."
            },
            {
              "texto": "Patrones estructurales."
            },
            {
              "texto": "Adapter. Convierte la interfaz de una clase en otra distinta que es la que esperan los clientes. Permiten que cooperen clases que de otra manera no podrían por tener interfaces incompatibles."
            },
            {
              "texto": "Bridge. Desvincula una abstracción de su implementación, de manera que ambas puedan variar de forma independiente. Composite. Combina objetos en estructuras de árbol para representar jerarquías de parte-todo. Permite que los clientes traten de manera uniforme a los objetos individuales y a los compuestos."
            },
            {
              "texto": "Decorator. Añade dinámicamente nuevas responsabilidades a un objeto, proporcionando una alternativa flexible a la herencia para extender la funcionalidad."
            },
            {
              "texto": "Facade. Proporciona una interfaz unificada para un conjunto de interfaces de un subsistema. Define una interfaz de alto nivel que hace que el subsistema se más fácil de usar."
            },
            {
              "texto": "Flyweight. Usa el compartimiento para permitir un gran número de objetos de grano fino de forma eficiente. Proxy. Proporciona un sustituto o representante de otro objeto para controlar el acceso a éste."
            },
            {
              "texto": "Composite. Permite combinar objetos en estructuras de árbol para representar jerarquías. Permite además, agrupar varios objetos como si fueran uno solo."
            }
          ]
        },
        {
          "texto": "Patrones de comportamiento",
          "element": "div",
          "listaUl": [
            {
              "texto": "Chain of Responsibility. Evita acoplar el emisor de una petición a su receptor, al dar a más de un objeto la posibilidad de responder a la petición. Crea una cadena con los objetos receptores y pasa la petición a través de la cadena hasta que esta sea tratada por algún objeto."
            },
            {
              "texto": "Command. Encapsula una petición en un objeto, permitiendo así parametrizar a los clientes con distintas peticiones, encolar o llevar un registro de las peticiones y poder deshacer la operaciones."
            },
            {
              "texto": "Interpreter. Dado un lenguaje, define una representación de su gramática junto con un intérprete que usa dicha representación para interpretar las sentencias del lenguaje."
            },
            {
              "texto": "Iterator. Proporciona un modo de acceder secuencialmente a los elementos de un objeto agregado sin exponer su representación interna."
            },
            {
              "texto": "Mediator. Define un objeto que encapsula cómo interactúan un conjunto de objetos. Promueve un bajo acoplamiento al evitar que los objetos se refieran unos a otros explícitamente, y permite variar la interacción entre ellos de forma independiente. Memento. Representa y externaliza el estado interno de un objeto sin violar la encapsulación, de forma que éste puede volver a dicho estado más tarde."
            },
            {
              "texto": "Observer. Define una dependencia de uno-a-muchos entre objetos, de forma que cuando un objeto cambia de estado se notifica y actualizan automáticamente todos los objetos."
            },
            {
              "texto": "State. Permite que un objeto modifique su comportamiento cada vez que cambia su estado interno. Parecerá que cambia la clase del objeto."
            },
            {
              "texto": "Strategy. Define una familia de algoritmos, encapsula uno de ellos y los hace intercambiables. Permite que un algoritmo varíe independientemente de los clientes que lo usan."
            },
            {
              "texto": "Template Method. Define en una operación el esqueleto de un algoritmo, delegando en las subclases algunos de sus pasos. Permite que las subclases redefinan ciertos pasos del algoritmo sin cambiar su estructura"
            },
            {
              "texto": "Visitor. Representa una operación sobre los elementos de una estructura de objetos. Permite definir una nueva operación sin cambiar las clases de los elementos sobre los que opera."
            },
            {
              "texto": "Memento. Se utiliza para guardar el estado de un objeto y poder luego restaurar el objeto a un estado previo."
            },
            {
              "texto": "Proxy. Proporciona un representante o delegado que se encargua de controlar el acceso a un objeto, generalmente por motivos de eficiencia."
            }
          ]
        }
      ]
    },
    {
      "titulo": "¿Qué es SOLID?",
      "complemento": [
        {
          "texto": "SOLID es el acrónimo que acuñó Michael Feathers, basándose en los principios de la programación orientada a objetos que Robert C. Martin había recopilado en el año 2000 en su paper “Design Principles and Design Patterns”.",
          "element": "div"
        },
        {
          "texto": "Los 5 principios SOLID de diseño de aplicaciones de software son:",
          "element": "div",
          "listaUl": [
            {
              "texto": "S – Single Responsibility Principle (SRP)"
            },
            {
              "texto": "O – Open/Closed Principle (OCP)"
            },
            {
              "texto": "L – Liskov Substitution Principle (LSP)"
            },
            {
              "texto": "I – Interface Segregation Principle (ISP)"
            },
            {
              "texto": "D – Dependency Inversion Principle (DIP)"
            }
          ]
        },
        {
          "texto": "1. Principio de Responsabilidad Única",
          "element": "div"
        },
        {
          "texto": "“A class should have one, and only one, reason to change.” La S del acrónimo del que hablamos hoy se refiere a Single Responsibility Principle (SRP). Según este principio “una clase debería tener una, y solo una, razón para cambiar”. Es esto, precisamente, “razón para cambiar”, lo que Robert C. Martin identifica como “responsabilidad”. El principio de Responsabilidad Única es el más importante y fundamental de SOLID, muy sencillo de explicar, pero el más difícil de seguir en la práctica. El propio Bob resume cómo hacerlo: “Gather together the things that change for the same reasons. Separate those things that change for different reasons”, es decir: “Reúne las cosas que cambian por las mismas razones. Separa aquellas que cambian por razones diferentes”.",
          "element": "div"
        },
        {
          "texto": "2. Principio de Abierto/Cerrado",
          "element": "div"
        },
        {
          "texto": "“You should be able to extend a classes behavior, without modifying it.”El segundo principio de SOLID lo formuló Bertrand Meyer en 1988 en su libro “Object Oriented Software Construction” y dice: “Deberías ser capaz de extender el comportamiento de una clase, sin modificarla”. En otras palabras: las clases que usas deberían estar abiertas para poder extenderse y cerradas para modificarse.En su blog Robert C. Martin defendió este principio que a priori puede parecer una paradoja. Es importante tener en cuenta el Open/Closed Principle (OCP) a la hora de desarrollar clases, librerías o frameworks.",
          "element": "div"
        },
        {
          "texto": "3. Principio de Sustitución de Liskov",
          "element": "div"
        },
        {
          "texto": "“Derived classes must be substitutable for their base classes.” La L de SOLID alude al apellido de quien lo creó, Barbara Liskov, y dice que “las clases derivadas deben poder sustituirse por sus clases base”. Esto significa que los objetos deben poder ser reemplazados por instancias de sus subtipos sin alterar el correcto funcionamiento del sistema o lo que es lo mismo: si en un programa utilizamos cierta clase, deberíamos poder usar cualquiera de sus subclases sin interferir en la funcionalidad del programa. Según Robert C. Martin incumplir el Liskov Substitution Principle (LSP) implica violar también el principio de Abierto/Cerrado.",
          "element": "div"
        },
        {
          "texto": "4. Principio de Segregación de la Interfaz",
          "element": "div"
        },
        {
          "texto": "“Make fine grained interfaces that are client specific.” En el cuarto principio de SOLID, el tío Bob sugiere: “Haz interfaces que sean específicas para un tipo de cliente”, es decir, para una finalidad concreta. En este sentido, según el Interface Segregation Principle (ISP), es preferible contar con muchas interfaces que definan pocos métodos que tener una interface forzada a implementar muchos métodos a los que no dará uso.",
          "element": "div"
        },
        {
          "texto": "5. Principio de Inversión de Dependencias",
          "element": "div"
        },
        {
          "texto": "“Depend on abstractions, not on concretions.” Llegamos al último principio: “Depende de abstracciones, no de clases concretas”. Así, Robert C. Martin recomienda: Los módulos de alto nivel no deberían depender de módulos de bajo nivel. Ambos deberían depender de abstracciones. Las abstracciones no deberían depender de los detalles. Los detalles deberían depender de las abstracciones. El objetivo del Dependency Inversion Principle (DIP) consiste en reducir las dependencias entre los módulos del código, es decir, alcanzar un bajo acoplamiento de las clases.",
          "element": "div"
        }
      ]
    },
    {
      "titulo": "¿Qué es una Clase?",
      "complemento": [
        {
          "texto": "En informática, una clase es una plantilla para la creación de objetos de datos según un modelo predefinido. Las clases se utilizan para representar entidades o conceptos, como los sustantivos en el lenguaje. Cada clase es un modelo que define un conjunto de variables y métodos apropiados para operar con dichos datos. Cada objeto creado a partir de la clase se denomina instancia de la clase.",
          "element": "div"
        }
      ]
    },
    {
      "titulo": "¿Qué es y para que se utiliza la herencia?",
      "complemento": [
        {
          "texto": "La herencia (a la que habitualmente se denomina subclase) proviene del hecho de que la subclase (la nueva clase creada) contiene las atributos y métodos de la clase primaria. La principal ventaja de la herencia es la capacidad para definir atributos y métodos nuevos para la subclase, que luego se aplican a los atributos y métodos heredados. Esta particularidad permite crear una estructura jerárquica de clases cada vez más especializada. La gran ventaja es que uno ya no debe comenzar desde cero cuando desea especializar una clase existente. Como resultado, se pueden adquirir bibliotecas de clases que ofrecen una base que puede especializarse a voluntad (la compañía que vende estas clases tiende a proteger las datos miembro usando la encapsulación).",
          "element": "div"
        }
      ]
    },
    {
      "titulo": "¿Qué es y para que se utilizan las interfaces?",
      "complemento": [
        {
          "texto": "En programación orientada a objetos, una interfaz (también llamada protocolo) es un medio común para que los objetos no relacionados se comuniquen entre sí. Estas son definiciones de métodos y valores sobre los cuales los objetos están de acuerdo para cooperar.",
          "element": "div"
        }
      ]
    },
    {
      "titulo": "¿Qué es el polimorfismo?",
      "complemento": [
        {
          "texto": "En programación orientada a objetos se denomina polimorfismo a la capacidad que tienen los objetos de una clase de responder al mismo mensaje o evento en función de los parámetros utilizados durante su invocación. Un objeto polimórfico es una entidad que puede contener valores de diferentes tipos durante la ejecución del programa.",
          "element": "div"
        },
        {
          "texto": "Dicho de otra forma, el polimorfismo consiste en conseguir que un objeto de una clase se comporte como un objeto de cualquiera de sus subclases, dependiendo de la forma de llamar a los métodos de dicha clase o subclases. Una forma de conseguir objetos polimórficos es mediante el uso de punteros a la superclase. De esta forma podemos tener dentro de una misma estructura (arrays, listas, pilas, colas, ...) objetos de distintas subclases, haciendo que el tipo base de dichas estructuras sea un puntero a la superclase. Otros lenguajes nos dan la posibilidad de crear objetos polimórficos  con el operador new. La forma de utilizarlo, por ejemplo en java, sería:",
          "element": "div"
        },
        {
          "texto": "Superclase sup = new (Subclase);",
          "element": "div"
        },
        {
          "texto": "En la práctica esto quiere decir que un puntero a un tipo puede contener varios tipos diferentes, no  solo el creado. De esta forma podemos tener un puntero a un objeto de la clase Trabajador, pero este puntero puede estar apuntando a un objeto subclase de la anterior como podría ser Márketing, Ventas o Recepcionistas (todas ellas deberían ser subclase de Trabajador).",
          "element": "div"
        }
      ]
    },
    {
      "titulo": "¿Qué es y cómo funciona una API web?",
      "complemento": [
        {
          "texto": "Una API es un conjunto de definiciones y protocolos que se utiliza para desarrollar e integrar el software de las aplicaciones. API significa interfaz de programación de aplicaciones. Las API permiten que sus productos y servicios se comuniquen con otros, sin necesidad de saber cómo están implementados. Esto simplifica el desarrollo de las aplicaciones y permite ahorrar tiempo y dinero. Las API le otorgan flexibilidad; simplifican el diseño, la administración y el uso de las aplicaciones, y proporcionan oportunidades de innovación, lo cual es ideal al momento de diseñar herramientas y productos nuevos (o de gestionar los actuales).",
          "element": "div"
        },
        {
          "texto": "A veces, las API se consideran como contratos, con documentación que representa un acuerdo entre las partes: si una de las partes envía una solicitud remota con cierta estructura en particular, esa misma estructura determinará cómo responderá el software de la otra parte.",
          "element": "div"
        }
      ]
    },
    {
      "titulo": "¿Qué herramientas se pueden utilizar para probar Web APIs?",
      "complemento": [
        {
          "texto": "",
          "element": "div",
          "listaUl": [
            {
              "texto": "Postman: es una herramienta para probar web services e interfaces de aplicación (API) en arquitectura REST. En términos generales, te permite enviar solicitudes post a cualquier servidor web y te proporciona y cataloga la respuesta."
            },
            {
              "texto": "Insomnia REST Client: es un cliente de REST API simple pero potente con administración de cookies, variables de entorno, generación de código y autenticación para Mac, Windows y Linux."
            },
            {
              "texto": "JMeter es una herramienta simple pero poderosa para pruebas automatizadas. Puede realizar pruebas de rendimiento de los servicios RESTFul con el uso de scripts de JMeter, y puede usar diferentes lenguajes como Java, JavaScript y PHP. Está diseñado para probar aplicaciones web, pero más adelante se expandió a otras funciones de prueba."
            },
            {
              "texto": "Swagger: Pavonearse, son las mejores herramientas de API de AKA para diseñar, construir y probar API. Las herramientas Swagger son tanto de código abierto como profesionales, y han ayudado a millones de desarrolladores y evaluadores a ofrecer una excelente API."
            }
          ]
        }
      ]
    },
    {
      "titulo": "¿Qué herramienta has utilizado para el manejo de errores?",
      "complemento": [
        {
          "texto": "La que más utilizo son las, “excepciones”. «Excepciones» es el nombre que reciben los errores de ejecución cuando un lenguaje de programación tiene mecanismos de manejo de excepciones y consisten en una notificación indicando que algo interrumpió la ejecución normal del programa. El manejo de excepciones fue introducido inicialmente en el lenguaje PL/1 y le permite a los programas detectar y reaccionar ante eventos inesperados. También permite eliminar el código para el manejo de errores del flujo principal de ejecución del programa, lo que mejora su claridad, mantenibilidad y rendimiento.",
          "element": "div"
        },
        {
          "texto": "El propósito principal de este mecanismo es ayudar a transferir información del punto donde se genera el error al punto donde el error se puede manejar. Cuando surge una excepción, la subrutina donde se generó puede «manejar» la excepción y continuar con la ejecución del programa. Pero si no lo hace, la excepción interrumpe la ejecución y se propaga a la sección del programa donde se invocó la subrutina.",
          "element": "div"
        },
        {
          "texto": "Otras conocidas, pero no tan utilizadas por lo menos por mí:",
          "element": "div",
          "listaUl": [
            {
              "texto": "Valores de retorno especiales"
            },
            {
              "texto": "Indicadores explícitos de resultado."
            }
          ]
        }
      ]
    },
    {
      "titulo": "Test driven development",
      "complemento": [
        {
          "texto": "El test-driven development es una metodología de diseño de software que se basa en test o pruebas para guiar el proceso. Al contrario de lo que ocurre en metodologías que posponen los test a un punto ulterior, los casos de prueba en TDD se realizan al inicio del proceso de diseño. Los test que se utilizan en esta metodología difieren en cuanto a propósito y alcance: el más sencillo es el test de módulos ounit test. Con él se prueban los componentes individuales de un programa informático. Otros test más complejos son las pruebas funcionales y de integración, que examinan la interacción entre las distintas partes del sistema y la funcionalidad del software en conjunto.",
          "element": "div"
        }
      ]
    }
  ]